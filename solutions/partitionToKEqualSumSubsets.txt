class Solution {
    //[4,3,2,3,5,2,1], k=4
    public boolean canPartitionKSubsets(int[] nums, int k) {
        int sum = 0; 
        for(int i : nums) {
            sum+=i;
        }
        if((sum % k) != 0) { //sum->20 % 4==0
            return false;
        }
        int target = sum / k;
        Arrays.sort(nums); //sum-> [1,2,2,3,3,4,5]
        boolean[] used = new boolean[nums.length];
        reverse(nums);
        return recursion(nums, k, 0, 0, target, used);
    }

    //nums=[5,4,3,3,2,2,1]
    private boolean recursion(int[] nums, int k, int index, int currentSum, int target, boolean[] used) {

        if(k == 1) { //k->4->3
            return true;
        }

        if(currentSum == target) {//cs->0->5->4->5                       target->5                      
            return recursion(nums, k - 1, 0, 0, target, used); //k->3->2
        }

        for(int i = index; i < nums.length;i++) { //i->0->1(4)->2(3)->3(3)->4(2)->5(2)->6(1)
            if(used[i] || currentSum + nums[i] > target) {//used[1]->false || cs->5->4, used[2]->true || cs+num->7->6->5      t->5
                continue;
            }
            used[i] = true; //used[i]->true,used[1]->true->used[5]=true
            if(recursion(nums, k, i + 1, currentSum + nums[i],target, used)) { //index->1->2->6
                return true;
            }
            used[i] = false; //used[0]->false, used[5]=true
        }
        return false;
    }
    private void reverse(int[] nums) {
        for(int i = 0, j = nums.length - 1; i < j; i++, j--) {
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
}